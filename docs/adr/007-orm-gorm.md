# ADR-007: ORM として GORM を採用

## ステータス

Accepted

## コンテキスト

PostgreSQL データベースとのやり取りを行う方法を選定する必要があった。

以下の要件を考慮した:
- 開発効率
- 型安全性
- マイグレーションとの連携
- リレーションのサポート
- パフォーマンス

## 決定

**GORM** を採用する。

```go
type Voice struct {
    ID       uuid.UUID `gorm:"type:uuid;primaryKey"`
    Provider string    `gorm:"type:varchar(50);not null"`
    Name     string    `gorm:"type:varchar(100);not null"`
}

db.Where("provider = ?", provider).Find(&voices)
```

## 選択肢

### 選択肢 1: GORM

- **メリット**
  - Go で最も人気のある ORM
  - 豊富な機能（リレーション、フック、トランザクション）
  - 自動マイグレーション機能
  - 学習リソースが豊富
- **デメリット**
  - 複雑なクエリではパフォーマンスに注意が必要

### 選択肢 2: sqlx

- **メリット**
  - 生 SQL に近い操作
  - 高パフォーマンス
  - 構造体へのマッピングをサポート
- **デメリット**
  - リレーション管理は手動

### 選択肢 3: ent

- **メリット**
  - Facebook 製の型安全な ORM
  - コード生成ベース
  - GraphQL との親和性が高い
- **デメリット**
  - 学習コストが高い

### 選択肢 4: sqlc

- **メリット**
  - SQL からコードを生成
  - 型安全
- **デメリット**
  - SQL を直接書く必要あり
  - スキーマ変更時の追従が手動

### 選択肢 5: 標準ライブラリ (database/sql)

- **メリット**
  - 依存なし
- **デメリット**
  - ボイラープレートが多い
  - 生産性が低い

## 理由

1. **開発効率**: CRUD 操作が簡潔に書ける
2. **エコシステム**: Go ORM の事実上の標準
3. **柔軟性**: 必要に応じて生 SQL も使用可能
4. **チェーンメソッド**: 動的なクエリ構築が容易
5. **ドキュメント**: 公式ドキュメントが充実

## 結果

- `gorm.io/gorm` と `gorm.io/driver/postgres` を使用
- モデル定義は `internal/model/` に配置
- 複雑なクエリはパフォーマンスを考慮して最適化
- マイグレーションは golang-migrate で別管理（ADR-008 参照）
