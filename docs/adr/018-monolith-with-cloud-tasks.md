# ADR-018: ワーカー処理を分離せずモノリス + Cloud Tasks 構成を維持

## ステータス

Proposed

## コンテキスト

台本生成（LLM パイプライン）と音声生成（TTS + FFmpeg）は重い非同期処理であり、API サーバーとは異なるリソース特性を持つ。これらを別サービス（Worker）として切り出すべきか検討した。

現在の構成：
- 単一 Go バイナリが REST API とワーカーエンドポイントの両方を提供
- Google Cloud Tasks がジョブキューとして機能し、ワーカーエンドポイントに HTTP コールバックを送信
- ローカル開発時は Cloud Tasks なしで goroutine フォールバックが動作

## 決定

ワーカー処理を別サービスに分離せず、**モノリス + Cloud Tasks** の現行構成を維持する。

## 選択肢

### 選択肢 1: モノリス + Cloud Tasks（現行）

- メリット
  - コードベース・デプロイパイプラインが1本で済み、運用がシンプル
  - サービス間通信や共有モデルの同期が不要
  - ローカル開発時に複数サービスの起動が不要
  - Cloud Tasks による非同期化で API のレスポンスはブロックされない
- デメリット
  - API と Worker のスケールを独立に制御できない
  - FFmpeg を含むため Docker イメージが大きくなる

### 選択肢 2: API / Worker をサービス分離

- メリット
  - API と Worker を独立にスケール可能（CPU/メモリを最適配分）
  - Worker 側だけのデプロイが可能（プロンプト変更など）
  - API 側の Docker イメージから FFmpeg を除外し軽量化できる
- デメリット
  - デプロイ・監視の運用コストが増加
  - 共有コードの管理が複雑になる（モノレポ or 共有パッケージ）
  - ローカル開発環境のセットアップが煩雑になる

### 選択肢 3: Cloud Run Jobs を使用

- メリット
  - ジョブ実行に特化した実行環境で、長時間タスクに最適化されている
  - API サーバーとは完全に独立したライフサイクル
- デメリット
  - Cloud Tasks + HTTP コールバックと比較して構成が大きく変わる
  - WebSocket での進捗通知の仕組みを別途設計し直す必要がある
  - 既存のコード変更が大きい

## 理由

1. **Cloud Tasks で十分に非同期化されている**: ジョブ作成時は DB 書き込み + エンキューのみで即座にレスポンスを返すため、API のレイテンシに影響しない
2. **現段階のトラフィック規模では不要**: ユーザー数・ジョブ数が小さいうちはモノリスのシンプルさが勝る
3. **Cloud Run のオートスケールで対応可能**: インスタンス数の自動増減で API とワーカー両方の負荷に対応できる
4. **分離が必要になっても低コストで移行可能**: `cmd/api/` と `cmd/worker/` にビルドターゲットを分け、Cloud Tasks の `WORKER_URL` を変更するだけで切り替えられる設計になっている

## 結果

以下のシグナルが観測された場合、選択肢 2（サービス分離）への移行を検討する：

- 音声生成（FFmpeg）の CPU 使用が API のレイテンシに影響している
- API と Worker で異なるインスタンスタイプ（CPU/メモリ）を割り当てたい
- Worker 側だけを頻繁にデプロイする運用になった
- Docker イメージサイズによるコールドスタートの遅延が問題になった
