# ADR-013: トランザクション管理は Service 層で行う

## ステータス

Accepted

## コンテキスト

複数のリポジトリ操作を一つのトランザクションで実行する必要があるケースが発生した。例えば、台本生成 API では以下の操作を一括で行う必要がある:

1. 既存の台本行を削除
2. 新しい台本行を一括作成

これらの操作は全て成功するか、全て失敗するかのどちらかでなければならない（ACID 特性）。

トランザクション管理をどの層で行うべきかを決定する必要があった。

## 決定

**トランザクション管理は Service 層で行う**。

Service 層で `*gorm.DB` の `Transaction` メソッドを直接呼び出し、トランザクション内で使用するリポジトリをその場で生成する。

```go
// Service 層での実装例
err = s.db.Transaction(func(tx *gorm.DB) error {
    txScriptLineRepo := repository.NewScriptLineRepository(tx)

    if err := txScriptLineRepo.DeleteByEpisodeID(ctx, eid); err != nil {
        return err
    }

    // ... 他の操作

    return nil
})
```

## 選択肢

### 選択肢 1: Service 層でトランザクション管理（採用）

- **メリット**
  - シンプルで理解しやすい
  - Go/GORM プロジェクトで一般的なパターン
  - 追加の抽象化が不要
  - 「複数操作を一括で行う」というビジネスロジックを Service 層で表現できる
- **デメリット**
  - Service 層が `*gorm.DB` に依存する
  - Repository の抽象化が部分的に崩れる

### 選択肢 2: Unit of Work パターン

- **メリット**
  - Repository の抽象化を維持できる
  - テスタビリティが向上
- **デメリット**
  - 追加のインターフェースと実装が必要
  - 小〜中規模プロジェクトにはオーバーエンジニアリング

### 選択肢 3: Repository 層でトランザクション管理

- **メリット**
  - Service 層が DB に依存しない
- **デメリット**
  - 複数リポジトリをまたぐトランザクションが困難
  - ビジネスロジックが Repository に漏れる

## 理由

1. **プロジェクト規模との整合性**: 本プロジェクトは「レイヤードアーキテクチャ + 軽量 DDD」を採用しており、過度な抽象化よりシンプルさを優先する
2. **Go コミュニティの慣習**: GORM を使用するプロジェクトでは、Service 層でトランザクション管理を行うのが一般的
3. **実用性**: Unit of Work パターンは理論的には優れているが、実装コストに見合うメリットが現時点では少ない
4. **可読性**: トランザクションの範囲が Service メソッド内で明確に見える

## 結果

- トランザクションが必要な場合、Service 層で `s.db.Transaction()` を使用する
- トランザクション内では、`tx` を引数に新しいリポジトリインスタンスを生成する
- この決定により、Service 層は `*gorm.DB` への依存を持つことを許容する
- 将来的にプロジェクト規模が大きくなり、テスタビリティが重要になった場合は Unit of Work パターンへの移行を検討する
