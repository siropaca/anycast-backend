# ADR-001: レイヤードアーキテクチャの採用

## ステータス

Accepted

## コンテキスト

Anycast Backend の開発にあたり、コードベースの構造を決定する必要があった。

プロジェクトの特性として以下を考慮した:
- 中規模のプロジェクト（10+ エンティティ）
- 外部サービス連携あり（GCS、TTS API）
- 小規模チームでの開発
- テスタビリティの確保が重要

## 決定

**レイヤードアーキテクチャ + 軽量 DDD** を採用する。

```
Handler → Service → Repository → DB
```

- **Handler**: HTTP リクエスト/レスポンスの処理
- **Service**: ビジネスロジック
- **Repository**: データアクセス
- **Model**: ドメインモデル

## 選択肢

### 選択肢 1: レイヤードアーキテクチャ + 軽量 DDD

- Go らしいシンプルさを保てる
- テスタビリティを確保できる
- 学習コストが低い
- 過度に複雑にならない

### 選択肢 2: クリーンアーキテクチャ

- 厳密なレイヤー分離
- ボイラープレートが多い
- 小規模プロジェクトにはオーバーキル

### 選択肢 3: DDD（厳密）

- ドメインロジックの表現力が高い
- 学習コストが高い
- ドメインがそこまで複雑でない本プロジェクトには過剰

### 選択肢 4: CQRS / イベントソーシング

- 読み書きの最適化が可能
- 履歴追跡が容易
- 本プロジェクトの要件には複雑すぎる

## 理由

1. **Go のエコシステムとの親和性**: Go プロジェクトで最も一般的なパターンであり、多くのライブラリやツールがこのパターンを前提としている
2. **適切な複雑さ**: プロジェクト規模に対して過不足のない構造
3. **段階的な拡張性**: 必要に応じて DDD の概念を追加導入できる
4. **チームの生産性**: シンプルな構造により、新規メンバーのオンボーディングが容易

## 結果

- `internal/` 配下に `handler`, `service`, `repository`, `model` パッケージを配置
- 各レイヤー間はインターフェースで疎結合化
- テスト時はモックによる差し替えが可能
