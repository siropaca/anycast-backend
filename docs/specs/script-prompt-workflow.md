# 台本生成プロンプトワークフロー仕様

台本生成の品質を安定化させるための多段階ワークフロー仕様。

## 設計方針

- **分割生成 + 検証 + 部分修正** で品質を安定化する
- 入力を **スロット化（正規化）** して優先度を保つ
- **内容生成とラジオ化（人間味付与）を分離** する（同時にやると中身が痩せる）
- 役割（speaker の立ち回り）はシステムで固定せず、**対話品質の合格条件のみを強制** する
- LLM 呼び出し回数は **最大3回** に抑え、レイテンシとコストのバランスを取る
- **掛け合い（dialogue）とひとり語り（monologue）** の両形式に対応する

---

## ワークフロー概要

```
┌─────────────────────────────────────────────────────────────────┐
│                        台本生成ワークフロー                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Phase 1: ブリーフ正規化（コード処理・LLM 不使用）                    │
│  ┌───────────────────────────────────────────────────┐          │
│  │ User/Channel/Episode/Character 情報を                │          │
│  │ 構造化スロットに正規化                                 │          │
│  └───────────────────┬───────────────────────────────┘          │
│                      ▼                                          │
│  Phase 2: 素材+アウトライン生成（LLM 1回目）                       │
│  ┌───────────────────────────────────────────────────┐          │
│  │ 具体例・落とし穴・疑問候補を生成しつつ                    │          │
│  │ 密度ノルマ付きの3ブロック構成アウトラインを設計             │          │
│  └───────────────────┬───────────────────────────────┘          │
│                      ▼                                          │
│  Phase 3: 台本ドラフト生成（LLM 2回目）                           │
│  ┌───────────────────────────────────────────────────┐          │
│  │ アウトラインを元に台本を生成                             │          │
│  │ 構造制約に従った台詞ドラフト + ラジオ化リライトを同時実行    │          │
│  └───────────────────┬───────────────────────────────┘          │
│                      ▼                                          │
│  Phase 4: QA 検証+パッチ修正（コード検証 + 条件付き LLM 3回目）     │
│  ┌───────────────────────────────────────────────────┐          │
│  │ コードで定量チェック → 不合格時のみ LLM で局所修正         │          │
│  └───────────────────────────────────────────────────┘          │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Phase 1: ブリーフ正規化

### 目的

User / Channel / Episode / Character の情報を、誤解しにくい構造化スロットに整形する。  
単純連結による優先度崩壊を防ぎ、各 Phase のプロンプトで必要な情報だけを参照可能にする。

### 処理方式

コード処理のみ（LLM 不使用）。`script.NormalizeBrief()` で実装。

### 出力: 正規化ブリーフ（内部用 JSON 構造体）

```json
{
  "episode": {
    "title": "エピソードタイトル",
    "description": "エピソード説明",
    "goal": "エピソード固有の指示（episode.userPrompt）",
    "duration_minutes": 10
  },
  "channel": {
    "name": "チャンネル名",
    "description": "チャンネル説明",
    "category": "カテゴリ名",
    "style_guide": "チャンネル固有の指示（channel.userPrompt）"
  },
  "characters": [
    {
      "name": "話者名",
      "gender": "性別",
      "persona": "ペルソナ説明",
      "role_in_conversation": "会話での立ち回り（任意・未設定なら空）",
      "interaction_style": "対話スタイル（任意・未設定なら空）"
    }
  ],
  "master_guide": "ユーザー基本方針（user.userPrompt）",
  "theme": "今回のテーマ（ユーザー入力 prompt）",
  "constraints": {
    "talk_mode": "dialogue",
    "with_emotion": false,
    "tts_optimized": true,
    "avoid": ["ユーザーが避けたい内容（将来拡張枠）"]
  }
}
```

### talk_mode の判定

`constraints.talk_mode` はキャラクター数から自動判定する:

| キャラクター数 | talk_mode | 説明 |
|-------------|-----------|------|
| 1人 | `monologue` | ひとり語り形式 |
| 2人以上 | `dialogue` | 掛け合い形式 |

Phase 2〜4 のプロンプトと合格条件は `talk_mode` に応じて切り替わる（詳細は各 Phase を参照）。

### スロットの優先度

プロンプト内での参照順序（上が最優先）:

1. `theme` — 今回のテーマ（最も具体的な指示）
2. `episode.goal` — エピソード固有の設定
3. `channel.style_guide` — チャンネルのスタイル方針
4. `master_guide` — ユーザーの基本方針（最も汎用的）
5. `characters` — キャラクター情報
6. `constraints` — 制約条件

### 備考

- `role_in_conversation` / `interaction_style` は現時点では DB スキーマにないフィールド
  - 将来的に Character モデルまたは ChannelCharacter の中間テーブルに追加を検討する
- 未設定でも動作する設計とする（未指定なら LLM が自然に判断）

---

## Phase 2: 素材+アウトライン生成

### 目的

1. 薄さを防ぐ「タネ」（具体例・落とし穴・疑問）を用意する
2. 内容密度を構造で固定する3ブロック構成のアウトラインを設計する

この2つを **1回の LLM 呼び出し** で同時に行い、効率化する。

### LLM 呼び出し仕様

| 項目 | 値 |
|------|------|
| 呼び出し回数 | 1回 |
| 入力 | 正規化ブリーフ（Phase 1 出力） |
| 出力形式 | JSON |
| Temperature | 0.9（創造的な素材生成のためやや高め） |

### システムプロンプト（Phase 2 用）

`talk_mode` によるプロンプトの差分はない。素材とアウトラインの構造は dialogue / monologue で共通。  
ただし、`questions` の性質が異なる点をユーザープロンプト側で補足する:

- **dialogue**: 話者間で投げかけ合う疑問
- **monologue**: リスナーに向けた問いかけ、または話者自身の自問

```
あなたはポッドキャスト台本の構成作家です。
与えられたテーマとチャンネル情報をもとに、内容の濃い台本を作るための
「素材」と「アウトライン」を JSON 形式で出力してください。

## 出力要件

### 素材（grounding）
テーマに関する以下の要素を各ブロック向けに複数用意する:
- definitions: 用語の短定義（リスナーが理解に必要な最低限の説明）
- examples: 具体例候補（状況 + 数字 or 具体物を含む）
- pitfalls: 落とし穴・よくある誤解候補
- questions: リスナーが抱きそうな疑問候補
- action_steps: 実務の一歩（聞いた後に実践できること）

### アウトライン（outline）
本題を3ブロックに分割し、各ブロックに以下を必ず割り当てる:
- ブロックの主題（1文で要約）
- 使用する具体例（grounding.examples から選択）
- 使用する落とし穴（grounding.pitfalls から選択）
- 使用するアクションステップ（grounding.action_steps から選択）
- 投げかける疑問（grounding.questions から選択）

## 制約
- 素材は各カテゴリ最低3個ずつ用意する
- アウトラインは必ず3ブロック構成とする
- 各ブロックに example / pitfall / action_step / question を最低1つずつ含める
- JSON 以外のテキストは出力しない
```

### 出力スキーマ

```json
{
  "grounding": {
    "definitions": [
      { "term": "用語", "definition": "短定義" }
    ],
    "examples": [
      { "id": "ex1", "situation": "状況説明", "detail": "数字や具体物を含む詳細" }
    ],
    "pitfalls": [
      { "id": "pit1", "misconception": "誤解の内容", "reality": "実際はこう" }
    ],
    "questions": [
      { "id": "q1", "question": "疑問文" }
    ],
    "action_steps": [
      { "id": "act1", "step": "具体的なアクション" }
    ]
  },
  "outline": {
    "opening": {
      "hook": "冒頭の掴み（1文）"
    },
    "blocks": [
      {
        "block_number": 1,
        "topic": "ブロックの主題",
        "example_ids": ["ex1"],
        "pitfall_ids": ["pit1"],
        "action_step_ids": ["act1"],
        "question_ids": ["q1"]
      }
    ],
    "closing": {
      "summary": "まとめ（1文）",
      "takeaway": "リスナーへのメッセージ（1文）"
    }
  }
}
```

---

## Phase 3: 台本ドラフト生成

### 目的

Phase 2 のアウトラインと素材を元に、台本（台詞形式）を生成する。  
構造制約に従いつつ、ラジオらしい人間味を含めた最終形に近い出力を目指す。  
`talk_mode` に応じて掛け合い形式またはひとり語り形式で生成する。

### LLM 呼び出し仕様

| 項目 | 値 |
|------|------|
| 呼び出し回数 | 1回 |
| 入力 | 正規化ブリーフ + Phase 2 出力（素材+アウトライン） |
| 出力形式 | テキスト（`話者名: セリフ` 形式） |
| Temperature | 0.7（内容の忠実性と自然さのバランス） |

### システムプロンプト（Phase 3 用）

`talk_mode` に応じて2種類のシステムプロンプトを使い分ける。
共通部分が多いため、差分箇所を明示する。

#### dialogue 用（掛け合い形式）

```
あなたはポッドキャスト台本を作成する専門家です。
与えられたアウトラインと素材を元に、掛け合い形式の台本を作成してください。

## 構造ルール（必須）
- 冒頭（オープニング） → 本題3ブロック → 締め（クロージング）の構成に従う
- 各ブロックで以下を台詞として必ず含める:
  - 具体例（状況 + 数字 or 具体物）
  - 落とし穴・よくある誤解
  - 実務の一歩（リスナーが実践できること）
- 各ブロックで最低1回、以下のいずれかの相互作用を含める:
  - 疑問・反論 → 回収
  - 確認・言い換え → 補足
- 同一話者が4行以上連続で一方的に説明しない

## 台詞ルール
- 1つのセリフは20〜80文字程度
- セリフは文として完結させる（体言止めや中途半端な切れ方にしない）
- セリフの末尾に句点（。）は付けない
- セリフ中に句点を入れない（1行に1文。同一話者の連続発言は複数行に分ける）
- TTS 前提: 記号連打（！！！、…… 等）/ 過度なスラング / 笑い声表記は避ける
- 人間らしさ:
  - 相槌やフィラー（「えーと」「まあ」「なんか」等）を適度に含める
  - 各ブロックに最低1回: 相槌、言い換え、軽いツッコミ or あるあるネタ
  - 文長にゆらぎを持たせる（全部同じ長さにしない）
- 短すぎるセリフ（単語だけ・相槌だけ）は避け、必ず文章として成立させる
  - 悪い例：「そうそう」「うん」「なるほど」だけの行
  - 良い例：「そうそう、まさにそういうことなんだよね」

## 話者の扱い
- 話者名は与えられたキャラクターリストの名前のみ使用可能
- キャラクターのペルソナ（性格・話し方）を反映する
- role_in_conversation / interaction_style が指定されていれば従う
- 未指定の場合はシステムが固定せず、自然な範囲で調整する

## 分量
- 1分あたり約300文字を目安に、指定されたエピソード長に合わせる

## 出力形式
話者名: セリフ

- 1行につき1つのセリフ
- 空行は入れない
- 台本テキスト以外の説明文・コメント・見出し・メタ発言は出力しない

例：
太郎: こんにちは、今日もよろしくお願いします
太郎: 今日はいい天気だから気分がいいね
花子: やあ、元気そうで何よりだね

## 出力形式（感情あり版）
話者名: [感情] セリフ

- 感情は省略可能。指定する場合は [感情] の形式でセリフの前に記載

例：
太郎: こんにちは、今日もよろしくお願いします
花子: [嬉しそうに] やあ、元気そうで何よりだね

## 制約
- アウトラインの素材（具体例・落とし穴・実務の一歩）は必ず台詞に組み込む。省略・要約しない
- 制作側のメタ発言はしない
```

#### monologue 用（ひとり語り形式）

dialogue 用との差分を **太字** で示す。

```
あなたはポッドキャスト台本を作成する専門家です。
与えられたアウトラインと素材を元に、ひとり語り形式の台本を作成してください。

## 構造ルール（必須）
- 冒頭（オープニング） → 本題3ブロック → 締め（クロージング）の構成に従う
- 各ブロックで以下を台詞として必ず含める:
  - 具体例（状況 + 数字 or 具体物）
  - 落とし穴・よくある誤解
  - 実務の一歩（リスナーが実践できること）
- 各ブロックで最低1回、以下のいずれかを含める:
  - リスナーへの問いかけ（「〜って思いませんか」「〜なんですよね」等）
  - 自問自答（「じゃあ〜はどうなのか」→ 自分で回答）
  - 前言の補足・言い換え（「つまり〜ということなんです」）

## 台詞ルール
- 1つのセリフは20〜80文字程度
- セリフは文として完結させる（体言止めや中途半端な切れ方にしない）
- セリフの末尾に句点（。）は付けない
- セリフ中に句点を入れない（1行に1文。続けて話す場合は複数行に分ける）
- TTS 前提: 記号連打（！！！、…… 等）/ 過度なスラング / 笑い声表記は避ける
- 人間らしさ:
  - フィラー（「えーと」「まあ」「なんか」等）を適度に含める
  - 各ブロックに最低1回: 問いかけ、例え話、体験談風の語り
  - 文長にゆらぎを持たせる（全部同じ長さにしない）
  - 語り口に緩急をつける（説明→問いかけ→エピソード→まとめ等のリズム変化）
- 短すぎるセリフ（単語だけ）は避け、必ず文章として成立させる

## 話者の扱い
- 話者は1人のみ。与えられたキャラクターの名前を使用する
- キャラクターのペルソナ（性格・話し方）を反映する
- interaction_style が指定されていれば従う

## 分量
- 1分あたり約300文字を目安に、指定されたエピソード長に合わせる

## 出力形式
話者名: セリフ

- 1行につき1つのセリフ
- 空行は入れない
- 台本テキスト以外の説明文・コメント・見出し・メタ発言は出力しない

例：
太郎: こんにちは、今日もよろしくお願いします
太郎: 今日はちょっと面白いテーマを持ってきました

## 出力形式（感情あり版）
話者名: [感情] セリフ

- 感情は省略可能。指定する場合は [感情] の形式でセリフの前に記載

例：
太郎: こんにちは、今日もよろしくお願いします
太郎: [ワクワクした様子で] 今日はちょっと面白いテーマを持ってきました

## 制約
- アウトラインの素材（具体例・落とし穴・実務の一歩）は必ず台詞に組み込む。省略・要約しない
- 制作側のメタ発言はしない
```

#### dialogue / monologue の主な差分まとめ

| 項目 | dialogue | monologue |
|------|----------|-----------|
| 冒頭の指示 | 「掛け合い形式の台本」 | 「ひとり語り形式の台本」 |
| 相互作用ノルマ | 話者間の疑問→回収 / 確認→補足 | リスナーへの問いかけ / 自問自答 / 前言の補足 |
| 話者連続制限 | 同一話者4行以上連続 NG | **制限なし**（全行が同一話者） |
| 人間味の出し方 | 相槌、ツッコミ、あるある | 問いかけ、例え話、体験談風の語り、語り口の緩急 |
| 話者の扱い | 複数話者、role_in_conversation 対応 | 1人のみ、interaction_style 対応 |

---

## Phase 4: QA 検証+パッチ修正

### 目的

生成された台本の品質をチェックし、不合格箇所のみ局所修正する。
**全文書き直しは行わない**（部分パッチのみ）。

### 検証方式: コード定量チェック + 条件付き LLM 修正

品質チェックを **コードで定量的に行える項目** と **LLM に判断を委ねる項目** に分類する。

#### コード定量チェック（LLM 不使用）

パーサーの拡張で実装する。以下のチェックに1つでも不合格があれば、LLM パッチ修正に進む。
一部のチェック項目は `talk_mode` によって条件が変わる。

##### 共通チェック（dialogue / monologue 共通）

| チェック項目 | 合格条件 | 検出方法 |
|------------|---------|---------|
| セリフ長 | 全セリフが10〜120文字以内 | 文字数カウント |
| 句点なし終了 | セリフの末尾が句点（。）で終わっていない | 末尾チェック |
| セリフ中句点なし | セリフ中に句点（。）が含まれていない | 文字列検索 |
| ブロック構造 | 台本が一定行数以上ある（duration × 4行/分 以上） | 行数チェック |
| 文長のゆらぎ | セリフ長の標準偏差が5文字以上 | 統計計算 |

##### dialogue 専用チェック

| チェック項目 | 合格条件 | 検出方法 |
|------------|---------|---------|
| 同一話者連続 | 同一話者が4行以上連続しない | パース結果の speaker を順番に走査 |
| 話者バランス | 各話者のセリフ数が全体の20%以上 | 話者別カウント |

##### monologue 専用チェック

| チェック項目 | 合格条件 | 検出方法 |
|------------|---------|---------|
| 話者一貫性 | 全セリフが同一話者である | パース結果の speaker が1種類か確認 |

#### LLM パッチ修正（条件付き・3回目の LLM 呼び出し）

コード定量チェックで不合格項目がある場合のみ実行する。

| 項目 | 値 |
|------|------|
| 呼び出し回数 | 0回（合格時）または 1回（不合格時） |
| 入力 | 台本テキスト + 不合格項目のリスト + 該当箇所の行番号 |
| 出力形式 | テキスト（修正後の台本全文） |
| Temperature | 0.5（修正のため低め） |

### LLM パッチ修正のシステムプロンプト

```
あなたはポッドキャスト台本の品質管理担当です。
以下の台本に対して、指摘された問題箇所のみを最小限に修正してください。

## 修正ルール
- 指摘された箇所の周辺のみを修正する
- 修正箇所以外のセリフは一切変更しない
- 具体例・落とし穴・実務の一歩は削除しない
- 修正後も全体の流れが自然になるよう配慮する
- 出力は台本全文（修正箇所を含む完全な台本）とする

## 出力形式
話者名: セリフ
（元の台本と同じ形式で全文を出力）
```

### パッチ修正のリトライ方針

- パッチ修正後に再度コード定量チェックを行う
- **リトライは最大1回** とする（計2回目のパッチ修正は行わない）
- 2回目のチェックでも不合格の場合は、最後の修正結果をそのまま採用しログに記録する

---

## 合格条件（全 Phase 共通・役割非依存）

台本として最低限満たすべき品質基準。Phase 3 のプロンプトに埋め込み、Phase 4 で検証する。
一部の条件は `talk_mode` によって異なる。

### 構造要件（共通）

| 項目 | 条件 |
|------|------|
| 全体構成 | オープニング → 本題3ブロック → クロージング |
| ブロック内容 | 各ブロックに具体例（状況+数字 or 具体物）/ 落とし穴 / 実務の一歩 |

### 構造要件（talk_mode 別）

| 項目 | dialogue | monologue |
|------|----------|-----------|
| 相互作用 | 各ブロックで最低1回: 疑問・反論・確認・言い換え → 回収 | 各ブロックで最低1回: リスナーへの問いかけ / 自問自答 / 前言の補足 |
| 話者連続 | 同一話者の一方的説明が4行以上連続しない | 制限なし（全行が同一話者） |

### 形式要件（共通）

| 項目 | 条件 |
|------|------|
| セリフ長 | 20〜80文字（目安）、10〜120文字（許容範囲） |
| 句点なし | セリフの末尾に句点（。）を付けない |
| 1行1文 | セリフ中に句点を含めない（1行に1文） |
| TTS 最適化 | 記号連打 / 過度なスラング / 笑い声表記を避ける |
| 出力形式 | `話者名: セリフ` のみ（見出し・メタ発言なし） |

### 対話品質要件（talk_mode 別）

| 項目 | dialogue | monologue |
|------|----------|-----------|
| 人間味 | 相槌 / 言い換え / ツッコミ / あるあるが各ブロックに最低1回 | 問いかけ / 例え話 / 体験談風の語り / 語り口の緩急が各ブロックに最低1回 |
| 文長バリエーション | 全セリフが同じ長さにならない（ゆらぎがある） | 同左 |
| 話者バランス | 各話者のセリフ数が全体の20%以上 | チェックなし（1人のみ） |
| 単調さ防止 | 話者交代で担保 | 話題転換・テンポ変化で担保（説明→問いかけ→エピソード→まとめ等のリズム） |

---

## 入力設計

### 入力マッピング

| 入力ソース | ブリーフスロット |
|-----------|----------------|
| `user.userPrompt` | `master_guide` |
| `channel.name` / `description` / `category` | `channel` |
| `channel.userPrompt` | `channel.style_guide` |
| `character.name` / `persona` / `voice.gender` | `characters` 配列 |
| `episode.title` / `description` | `episode` |
| `episode.userPrompt` | `episode.goal` |
| `request.prompt` | `theme` |
| `request.durationMinutes` | `episode.duration_minutes` |
| `request.withEmotion` | `constraints.with_emotion` |
| キャラクター数 | `constraints.talk_mode`（1人→monologue、2人以上→dialogue） |

### 将来拡張フィールド（任意）

Character またはChannelCharacter に追加可能なフィールド:

| フィールド | 型 | 説明 |
|-----------|------|------|
| role_in_conversation | string | 会話での立ち回り（例: 「聞き手」「ツッコミ役」） |
| interaction_style | string | 対話スタイル（例: 「テンポよく」「じっくり」） |
| taboo | string | このキャラクターが避けるべき表現や話題 |

これらは未設定でも動作する設計とする。

---

## 処理フロー（進捗目安）

| 進捗 | Phase | 処理内容 |
|------|-------|---------|
| 0% | - | ジョブ作成 |
| 5% | - | チャンネル・エピソード・ユーザー情報の読み込み |
| 10% | Phase 1 | ブリーフ正規化 |
| 15% | Phase 2 | 素材+アウトライン生成（LLM 1回目）開始 |
| 35% | Phase 2 | 素材+アウトライン生成 完了 |
| 40% | Phase 3 | 台本ドラフト生成（LLM 2回目）開始 |
| 75% | Phase 3 | 台本ドラフト生成 完了 |
| 80% | Phase 4 | QA 定量チェック |
| 85% | Phase 4 | パッチ修正（LLM 3回目、条件付き） |
| 90% | - | 台本パース・DB 保存 |
| 95% | - | 完了処理 |
| 100% | - | 完了 |

---

## LLM クライアント層への要件

### アーキテクチャ

`llm.Registry` で複数プロバイダのクライアントを管理し、Phase ごとに使用するプロバイダを切り替え可能にする。

```go
// Registry は複数の LLM クライアントを管理する
type Registry struct {
    clients map[Provider]Client
}

func NewRegistry() *Registry
func (r *Registry) Register(provider Provider, client Client)
func (r *Registry) Get(provider Provider) (Client, error)
func (r *Registry) Has(provider Provider) bool
```

### Phase 別設定

`internal/service/script_prompts.go` の `PhaseConfig` 構造体で Phase ごとのプロバイダと Temperature を定義する。

```go
type PhaseConfig struct {
    Provider    llm.Provider
    Temperature float64
}
```

| Phase | Provider | Temperature | 理由 |
|-------|----------|-------------|------|
| Phase 2 | OpenAI | 0.9 | 創造的な素材生成 |
| Phase 3 | OpenAI | 0.7 | 内容の忠実性と自然さのバランス |
| Phase 4 | OpenAI | 0.5 | 局所修正のため低め |

プロバイダを変更したい場合は `script_prompts.go` の `phaseXConfig` の `Provider` を変更するだけでよい。

### Client インターフェース

```go
type ChatOptions struct {
    Temperature *float64
}

type Client interface {
    Chat(ctx context.Context, systemPrompt, userPrompt string) (string, error)
    ChatWithOptions(ctx context.Context, systemPrompt, userPrompt string, opts ChatOptions) (string, error)
}
```

Phase 別に Temperature を変えるため `ChatWithOptions` メソッドを使用する。
`Chat` は `ChatWithOptions(ctx, sys, user, ChatOptions{})` に委譲し、デフォルト Temperature（0.7）を使用する。

---

## 実装上の注意

### Phase 2 の JSON パース

- LLM が JSON 以外のテキスト（説明文やマークダウン）を混入する可能性がある
- JSON 部分を抽出するユーティリティを用意する（```json ... ``` ブロックの抽出等）
- LLM が `outline` を配列形式で返す場合にも対応する（カスタム `UnmarshalJSON` で配列・オブジェクト両形式に対応）
- パース失敗時は最大2回リトライする
- それでも失敗した場合はエラーを返しジョブを失敗状態にする（精度の低い台本を生成しない）

### エラー戦略

各 Phase で致命的エラーが発生した場合の挙動:

| Phase | エラー | 挙動 |
|-------|-------|------|
| Phase 2 | JSON パース失敗（リトライ超過） | ジョブを失敗状態にしエラーを返す |
| Phase 3 | 台本パース失敗（0行） | ジョブを失敗状態にしエラーを返す |
| Phase 4 | パッチ修正後も不合格 | 最後の修正結果をそのまま採用 |

### キャンセルチェックポイント

各 LLM 呼び出しの前にキャンセルチェックを行う（現行と同様）:

- Phase 2 開始前
- Phase 3 開始前
- Phase 4（パッチ修正）開始前

---

## 関連ファイル

| ファイル | 説明 |
|---------|------|
| `internal/service/script_prompts.go` | Phase 2/3/4 のシステムプロンプト定義 |
| `internal/service/script_job.go` | 多段階ワークフローの実行ロジック |
| `internal/pkg/script/brief.go` | ブリーフ正規化（Phase 1） |
| `internal/pkg/script/grounding.go` | Phase 2 出力構造体とパーサー |
| `internal/pkg/script/validator.go` | QA 定量チェック（Phase 4） |
| `internal/pkg/script/json_extractor.go` | LLM 出力からの JSON 抽出ユーティリティ |
| `internal/infrastructure/llm/client.go` | `ChatWithOptions` インターフェース定義 |
| `internal/infrastructure/llm/registry.go` | LLM プロバイダ Registry |

